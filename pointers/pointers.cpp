// pointers.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#include <iostream>
using namespace std;

//адрес - это число 4 байта означающее порядковый номер байта в оперативной памяти
// & - оператор взятия адреса (address-of operator) - это унарный оператор котрый возвращает адрес своего операнда
// у & есть только префиксная форма записи (всегда ставится перед операндом)
// * - оператор разыменования (dereference operator) - это унарный оператор который возвращает значение по адресу
//* - только при обьявлении показывает что обьявляемая переменная - это указатель

#define POINTER_BASICS
//#define POINTER_AND_ARRAYS // указатели массивы
// define - определить
//  definietion - определение
// директива #define создает макроопределение показывает что заменить и чем заменить
//#define что_заменить чем_заменить
//директива - это указание компилятору на выполнение некоторых действий
int main()
{
    setlocale(LC_ALL, "ru");
#ifndef POINTER_BASICS // основы указателей
    // если определено pointer_basics то ниже следующий код будет виден компилятору
    int a = 2;
    int* pa = &a;
    cout << a << endl;
    cout << &a << endl;
    cout << pa << endl;
    cout << *pa << endl;

    int* pb;
    int b = 3;
    pb = &b;
    cout << *pb << endl;
#endif // !pointer_basics



#if defined POINTER_AND_ARRAYS
  /*имя массива является указателем на массив поскольку содержит адресс нулевого элемента массива
   а следовательно и всего массива
    используя арифметику указателей можно вычислить адрес лубого элемента массива

                   арифметика указателей
    компилятор всегда должен знать на какой тип данных указывает указатель
    это нужно длЯ того чтобы понимать сколько байт в памяти нужно считать или записать по адресу
    так же это нужно для арифметики указателей.
    над указателями можн применять арифметические операции +,-,++,--
    и результат операции будет зависть от типа данных на который указывает указатель.
    если указателю на char прибавить 1 то адрес измениться на 1 байт
    если указателю на int прибавить 1 то адрес измениться на 4 байт
    если указателю на double прибавить 1 то адрес измениться на 8 байт
    short занимает 2 байта
*/
    const int n = 5;
    short int arr[n] = { 3,5,8,13,21 };
    cout << arr << endl;
    cout << *arr << endl;
    for (int i = 0; i < n; i++) {

        //обращение к элементам массива через арифметику указателей и оператор разыменования
        cout << *(arr + i) << "\t";
    }
    cout << endl;
    /*
    доступ к элементам массива осуществляется за константное время поскольку сводятся к операции сложения а операция сложения всегда выполняется за константное время
    тоесть процессор на операцию сложеня всегда тратит одно и тоже количество тактов.
    */
    for (int i = 0; i < n; i++) {

        //[]  - оператор индексирования .он так же вычисляет адрес элемента массива и разыменовывает его 
        cout << arr[i] << "\t";
    }
    cout << endl;

#endif
    int a = 2;
    cout << *&a << endl;

}